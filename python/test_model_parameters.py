from argparse import ArgumentParser

import matplotlib.pyplot as plt
import pandas as pd
import xgboost
from pandas import read_csv, merge, DataFrame, np
from sklearn.metrics import accuracy_score
from xgboost import XGBRegressor

parser = ArgumentParser(description='Train model for cryptocurrency.')
parser.add_argument("-s", help="symbol of currency", type=str)

args = parser.parse_args()
symbol = args.s.strip()

short_window_size = 2
long_window_size = 5


def get_predictor(data):
    predictors = DataFrame({"open_sma": data.open.rolling(window=short_window_size).mean(),
                            "open_smal": data.open.rolling(window=long_window_size).mean(),

                            "low_sma": data.low.rolling(window=short_window_size).mean(),
                            "low_smal": data.low.rolling(window=long_window_size).mean(),

                            "close_sma": data.close.rolling(window=short_window_size).mean(),
                            "close_smal": data.close.rolling(window=long_window_size).mean(),

                            "high_sma": data.high.rolling(window=short_window_size).mean(),
                            "high_smal": data.high.rolling(window=long_window_size).mean(),

                            "spread_sma": data.spread.rolling(window=short_window_size).mean()})

    # additional features
    # predictors["spread_rel"] = data.spread_sma / data.open_sma + 0.0001  # avoid null division
    predictors["volume"] = data.volume + 0.001  # avoid null division
    predictors["spread"] = data.spread

    # The rows with nulls generated by rolling values will be removed.
    predictors = predictors.dropna()

    return predictors


def get_x_and_y(p):
    target = DataFrame({"value": p.spread}).dropna()

    X = merge(p, target, left_index=True, right_index=True)[p.columns]
    y = merge(p, target, left_index=True, right_index=True)[target.columns]

    return X, y


MAIN_DATA = read_csv("data/data-" + symbol + ".csv", sep=",", header=0, decimal='.')
MAIN_DATA = MAIN_DATA.set_index("date")

predictor = get_predictor(MAIN_DATA)
X, y = get_x_and_y(predictor)

train_samples = int(X.shape[0] * 0.75)

X_train = X.iloc[:train_samples]
X_test = X.iloc[train_samples:]

y_train = y.iloc[:train_samples]
y_test = y.iloc[train_samples:]


def getBinary(val):
    if val > 0:
        return 1
    else:
        return 0


# and the transformation is applied on the test data for later use.
# The train data will be transformed while it is being fit.
y_test_binary = pd.DataFrame(y_test["value"].apply(getBinary))

regressorLow = XGBRegressor(gamma=0.0, n_estimators=200, base_score=0.5, colsample_bytree=0.7, learning_rate=0.2, max_depth=5, objective="reg:linear")
xgbModelLow = regressorLow.fit(X_train, y_train.value)
xgboost.plot_importance(xgbModelLow)
y_predicted = xgbModelLow.predict(X_test)

y_predicted_binary = [1 if yp >=0.5 else 0 for yp in y_predicted]

print (accuracy_score(y_test_binary,y_predicted_binary))

fig = plt.figure(figsize=(8, 8))
plt.xticks(rotation='vertical')
y_pos = np.arange(len(xgbModelLow.feature_importances_))
plt.barh([i for i in range(len(xgbModelLow.feature_importances_))], xgbModelLow.feature_importances_.tolist(),
         align='center', alpha=0.4)
plt.yticks(y_pos, X_test.columns)
plt.show()
